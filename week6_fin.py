# 모두를 위한 파이썬 PY4E
# 6주차 팀 과제
# 팀: 턴태코치_2팀 / 작성자: jm / 기여자: chabbo, jm, Noas / 작성일: 220822
# 6주차 미션 목적 - 튜플과 딕셔너리 자료형의 이해와 활용

"""
딕셔너리는 순서가 없는 것이 맞지만 Python 3.7 버젼 이후로는 딕셔너리가 입력된 순서대로 출력이 됩니다. 강의에서는 3.6버젼이 사용된 것으로 보입니다.
a = {"a": 1 , "b": 22, "c": 15}
print(list(a))
["a", "b", "c"]
이점을 참고하시어 미션을 풀어 보시길 바랍니다.
 
📌Q1. 역사 문제를 하나 내보겠습니다. 고려시대와 조선시대 왕 이름 중에서 고려에도 있고 조선에도 있는 이름은 몇개 일까요? 한 번에 딱 안 떠오른다면 왕 이름을 드릴테니 파이썬 함수로 만들어서 출력 해봅시다.


😲조건1 - 중복되는 왕 이름 출력
😲조건2 - 중복되는 왕 이름의 수 출력
# 왕이름
korea_king = "태조,혜종,정종,광종,경종,성종,목종,현종,덕종,정종,문종,순종,선종,헌종,숙종,예종,인종,의종,명종,신종,희종,강종,고종,원조,충렬왕,충선왕,충숙왕,충혜왕,충목왕,충정왕,공민왕,우왕,창왕,공양왕"
chosun_king = "태조,정종,태종,세종,문종,단종,세조,예종,성종,연산군,중종,인종,명종,선조,광해군,인조,효종,현종,숙종,경종,영조,정조,순조,헌종,철종,고종,순종"
✅출력 예시
king(korea_king, chosun_king)
조선과 고려에 모두 있는 왕 이름 : 태조
조선과 고려에 모두 있는 왕 이름 : 정종
조선과 고려에 모두 있는 왕 이름 : 경종
조선과 고려에 모두 있는 왕 이름 : 성종
조선과 고려에 모두 있는 왕 이름 : 현종
조선과 고려에 모두 있는 왕 이름 : 문종
조선과 고려에 모두 있는 왕 이름 : 순종
조선과 고려에 모두 있는 왕 이름 : 헌종
조선과 고려에 모두 있는 왕 이름 : 숙종
조선과 고려에 모두 있는 왕 이름 : 예종
조선과 고려에 모두 있는 왕 이름 : 인종
조선과 고려에 모두 있는 왕 이름 : 명종
조선과 고려에 모두 있는 왕 이름 : 고종
조선과 고려에 모두 있는 왕 이름은 총 13개 입니다
"""

korea_king = "태조,혜종,정종,광종,경종,성종,목종,현종,덕종,정종,문종,순종,선종,헌종,숙종,예종,인종,의종,명종,신종,희종,강종,고종,원조,충렬왕,충선왕,충숙왕,충혜왕,충목왕,충정왕,공민왕,우왕,창왕,공양왕"

chosun_king = "태조,정종,태종,세종,문종,단종,세조,예종,성종,연산군,중종,인종,명종,선조,광해군,인조,효종,현종,숙종,경종,영조,정조,순조,헌종,철종,고종,순종"


#########################################################
#                        Noas                           #
#########################################################


#########################################################
#                        chabbo                         #
#########################################################


#########################################################
#                          jm                           #
#########################################################



#딕셔너리 강의 실습에서 배웠던 알고리즘을 활용해봤습니다.

# 중복되는 왕 이름과 수를 출력하는 함수
def kingCount():
    totalCount = 0                                                                      # totalCount: 중복되는 왕 이름의 수
    kingDict = dict()                                                                   # kingDict: 고려와 조선 왕을 모두 가진 딕셔너리

    korea_king_list = korea_king.split(',')                                             # korea_king_list: 고려의 왕 리스트
    chosun_king_list = chosun_king.split(',')                                           # chosun_king_list: 조선의 왕 리스트
    kingList = korea_king_list + chosun_king_list                                       # kingList : 고려와 조선의 왕 리스트를 합한 리스트

    for val in kingList:                                                                # kingList의 길이만큼 반복
        kingDict[val] = kingDict.get(val, 0) + 1                                            # kingDict에 kingList의 값을 KEY에, 중복되는 숫자를 VALUE에 대입하는 알고리즘

    for key, value in kingDict.items():                                                 # kingDict.items()의 길이만큼 키,값을 반환하는 포문
        if int(value) > 1 :                                                                 # 조선과 고려의 중복되는 왕이 2명 이상일 때
            totalCount += 1                                                                     # totalCount + 1
            print(f'조선과 고려에 모두 있는 왕 이름 : {key}')                                     # 조선과 고려의 중복되는 왕 이름 출력

    print(f'조선과 고려에 모두 있는 왕 이름은 총 {totalCount}개 입니다')                    # totalCount 출력


# 실행코드
kingCount()











"""
📌Q2.  여러분은 6명의 멤버를 거느리는 영업팀의 영업관리자 입니다. 각 멤버별로 올해 실적을 보고 잘한 멤버는 보너스를 주고 못한 멤버는 면담을 하려고 합니다. 파이썬을 이용하여 함수를 만들어 보너스 대상자와 면담 대상자를 골라주세요.

😲조건 1 - 예비 보너스 대상자는 평균 실적 1등 2등 입니다.
😲조건 2 - 예비 면담 대상자는 평균 실적 5등 6등 입니다.
😲조건 3 - 보너스 대상자의 평균 실적이 5보다 크지 않으면 보너스 대상자에서 제외 됩니다.
😲조건 4 - 면담 대상자의 평균 실적이 3보다 크면 면담 대상자에서 제외 됩니다.
# 이름, 실적
member_names = ["갑돌이", "갑순이", "을돌이", "을순이", "병돌이", "병순이"]
member_records = [[4,5,3,5,6,5,3,4,1,3,4,5],[2,3,4,3,1,2,0,3,2,5,7,2], 
           [1,3,0,3,3,4,5,6,7,2,2,1],[3,2,9,2,3,5,6,6,4,6,9,9],
           [8,7,7,5,6,7,5,8,8,6,10,9],[7,8,4,9,5,10,3,3,2,2,1,3]]
✅출력 예시
sales_management(member_names, member_records)
보너스 대상자 병돌이
보너스 대상자 을순이

면담 대상자 갑순이
"""

member_names = ["갑돌이", "갑순이", "을돌이", "을순이", "병돌이", "병순이"]
member_records = [[4,5,3,5,6,5,3,4,1,3,4,5],[2,3,4,3,1,2,0,3,2,5,7,2], 
           [1,3,0,3,3,4,5,6,7,2,2,1],[3,2,9,2,3,5,6,6,4,6,9,9],
           [8,7,7,5,6,7,5,8,8,6,10,9],[7,8,4,9,5,10,3,3,2,2,1,3]]


#########################################################
#                        Noas                           #
#########################################################



#########################################################
#                        chabbo                         #
#########################################################



#########################################################
#                          jm                           #
#########################################################


def sales_management(member_names, member_records):
    mbDict = dict()                                                                     # mbDict 딕셔너리 : 키 - 평균 실적 / 값 - 멤버이름 
    for i, v in enumerate(member_records):                                              # 실적 리스트 길이만큼 반복문을 돌려 인덱스, 값을 리턴
        recordSum = sum(v)                                                                  # recordSum: member_records의 하위 리스트(실적)의 합
        recordAve = int(recordSum//len(v))                                                  # recordAve: 멤버의 실적 평균값
        mbDict[recordAve] = member_names[i]                                                 # mbDict에 키 - 평균 실적 / 값 - 멤버이름 대입 
    
    
    for key, val in mbDict.items():                                                     # mbDict의 키,값을 리턴하는 반복문
        if key > 4:                                                                         # 평균 실적이 5 이상
            print(f'보너스 대상자: {val}')                                                      # 보너스 대상자 출력
        elif key < 3:                                                                       # 평균실적이 2 이하
            print(f'면담 대상자: {val}')                                                        # 면담 대상자 출력


#실행코드
print('\n-------------------------------------------')
print('보너스 대상자와 면담 대상자를 출력하는 프로그램입니다.')
print('-------------------------------------------')
sales_management(member_names, member_records)









"""
📌Q3. 예금 금리가 너무 낮아서 주식을 시작했습니다. 아래와 같이 매수한 종목 이름, 수량, 매수 평균 금액이 있습니다. 판매가는 따로 주어집니다. 종목과 수익률만 출력하시고 종목별 수익률이 높은 순서대로 출력해주세요. (소수 둘째자리까지 출력)

stocks = "삼성전자/10/85000,카카오/15/130000,LG화학/3/820000,NAVER/5/420000"
sells = [82000, 160000, 835000, 410000]
# 소수 둘째자리까지 출력하는 방법
a = 3.141592
print(f"{a:.3}")
3.14
✅출력 예시
stock_profit(stocks, sells)
카카오의 수익률 23.1
LG화학의 수익률 1.83
NAVER의 수익률 -2.38
삼성전자의 수익률 -3.53
"""

stocks = "삼성전자/10/85000,카카오/15/130000,LG화학/3/820000,NAVER/5/420000"
sells = [82000, 160000, 835000, 410000]

#########################################################
#                        Noas                           #
#########################################################



#########################################################
#                        chabbo                         #
#########################################################



#########################################################
#                          jm                           #
#########################################################


#지난번에 알려주신 sort 람다식을 활용해봤습니다.

def stock_profit(stocks, sells):                                                                                    # stocks, sells를 받아 주식 종목별 수익률이 높은 순서로 출력 함수
    myStock = stocks.split(',')                                                                                         # myStock: stocks을 종목별로 나눈 리스트
    stockDict = dict()                                                                                                  # stockDict: key - 종목명 / value - 수익률 을 담을 딕셔너리 준비

    for idx, val in enumerate(myStock):                                                                                 # 갖고있는 종목만큼 반복문
        items = val.split('/')                                                                                              # items: 종목명/ 보유량/ 매수 평균 금액 리스트
        buyPrice = int(items[2])                                                                                            # buyPrice: 매수 평균 금액 int화
        buyCount = int(items[1])                                                                                            # buyCount: 보유량 int화

        result = ((sells[idx] - buyPrice) / buyPrice)*100                                                                   # result: 수익률
        stockDict[items[0]] = round(result, 2)                                                                              # stockDict: key - 종목명 / value - 수익률  대입

    #람다식을 활용한 value 기반 오름차순 정렬
    #dict(sorted(stockDict.items(), key=lambda stockDict: stockDict[1]))
    stockDict = dict((sorted(stockDict.items(), key=lambda stockDict: stockDict[1], reverse=True)))                         # 람다식을 활용한 value 기반 내림차순 정렬, 딕셔너리형태로 변경

    for key, val in stockDict.items():                                                                                  # stockDict 아이템 길이만큼 반복문
        print(f'{key} 의 수익률 : {val}')                                                                                    # 출력


#실행코드
print('\n-------------------------------------------')
print('주식을 종목별 수익률이 높은 순서로 출력하는 프로그램입니다.')
print('-------------------------------------------')
stock_profit(stocks, sells)







"""
📌Q4. 여러분은 어떤 상품을 판매하고 있습니다. 매월 상품을 많이 구매해준 VIP회원에게 할인 쿠폰을 제공해주려고 합니다. 아래와 같은 회원 정보가 있을 때 회원 정보를 출력하고 할인 쿠폰을 받을 회원이 누구인지 출력하는 함수를 만들어 주세요.

😲조건1 - 8회 이상 구매한 회원이 VIP대상
😲조건2 - 전화번호가 없으면 쿠폰을 받을 수 없음
😲조건3 - 전화번호가 없으면 000-0000-0000으로 출력할 것

# 6명의 회원이고 "아이디,나이,전화번호,성별,지역,구매횟수" 순서로 입력되어 있음
info = "abc,21세,010-1234-5678,남자,서울,5,cdb,25세,x,남자,서울,4,bbc,30세,010-2222-3333,여자,서울,3,ccb,29세,x,여자,경기,9,dab,26세,x,남자,인천,8,aab,23세,010-3333-1111,여자,경기,10"
✅출력 예시
good_customer(info)
{'아이디': ['abc', 'cdb', 'bbc', 'ccb', 'dab', 'aab'], '나이': ['21세', '25세', '30세', '29세', '26세', '23세'], '전화번호': ['010-1234-5678', '000-0000-0000', '010-2222-3333', '000-0000-0000', '000-0000-0000', '010-3333-1111'], '성별': ['남자', '남자', '여자', '여자', '남자', '여자'], '지역': ['서울', '서울', '서울', '경기', '인천', '경기'], '구매횟수': [5, 4, 3, 9, 8, 10]}
할인 쿠폰을 받을 회원정보 아이디:aab, 나이:23세, 전화번호:010-3333-1111, 성별:여자, 지역:경기, 구매횟수: 10
"""



#########################################################
#                        Noas                           #
#########################################################



#########################################################
#                        chabbo                         #
#########################################################



#########################################################
#                          jm                           #
#########################################################


import re
from collections import defaultdict

# 딕셔너리를 다루는 작업은 재밌지만 인덱스가 없어 리스트를 활용, 접근하기가 까다롭네요..!
# 정규표현식을 활용해서 010-xxxx-xxxx 형식을 확인했습니다.
# 딕셔너리 값에 리스트를 넣기 위해 검색하다 defaultdict 함수를 알게되었습니다.

#분류 기준 리스트
subject_list = ['아이디', '나이', '전화번호', '성별', '지역', '구매횟수']
# 정보 스트링
info = "abc,21세,010-1234-5678,남자,서울,5,cdb,25세,x,남자,서울,4,bbc,30세,010-2222-3333,여자,서울,3,ccb,29세,x,여자,경기,9,dab,26세,x,남자,인천,8,aab,23세,010-3333-1111,여자,경기,10"

# 스트링에서 정보를 딕셔너리로 바꿔주는 함수
def good_customer(info):                                                                                    
    info_list = info.split(',')                                                                             # info_list : info를 ','로 나눈 리스트
    resultDict = defaultdict(list)                                                                          # resultDict: 키 - subject_list / 값 - 정보리스트. 값으로 리스트 형식을 갖도록 설정
    vipIndex_list = list()                                                                                  # vipIndex_list: 우수고객의 인덱스를 갖고있는 리스트 (resultDict의 값, 정보리스트의 인덱스)

    for idx, val in enumerate(info_list):                                                                   # info_list리스트의 길이만큼 반복문을 돌려 분류별로 고객 정보 리스트 정리
        criteria = idx%6                                                                                        # criteria: 인덱스/6 의 나머지의 값으로 분류 기준 인덱스 저장
        subject = subject_list[criteria]                                                                        # subject: 분류 기준 인덱스를 통해 현재 분류값을 subject_list에서 가져옴
        resultDict[subject].append(val)                                                                         # subject를 키값으로 갖는 resultDict의 값(리스트)에 해당 분류에 속하는 정보를 append

        if subject == '구매횟수' and int(val) > 7:                                                                  # subject가 구매횟수일 때, 해당 값이 8 이상인 경우
            vipIndex_list.append(list(resultDict[subject]).index(val))                                                  # vipIndex_list에 해당 값을 가진 인덱스를 저장. resultDict의 값 리스트의 인덱스.


    for value in vipIndex_list:                                                                             # vipIndex_list 길이만큼 만큼 반복문을 돌려 해당 고객의 정보를 출력
        phoneList = resultDict.get('전화번호')                                                                  # phoneList: resultDict에서 키가 '전화번호'인 값 리스트
        if re.match('^010\-\d{4}\-\d{4}', phoneList[value]):                                                   # '전화번호'인 값 리스트에서 vip고객에 해당하는 인덱스의 정보가 올바른 형식인지 확인
            print('---------- 할인 쿠폰을 받을 회원정보 ----------')                                             # vip에 해당하는 고객, 전화번호 형식이 올바른 고객임이 확인된 후 문구 출력
            for k, v in resultDict.items():                                                                         # resultDict의 값을 반복하여 특정 고객의 정보 출력
                customer = ""
                customer = customer + (k+': '+v[value])                                                                 # customer: customer + '분류(키): 리스트[특정인덱스]'
                print(customer)


#실행함수
good_customer(info)
            
